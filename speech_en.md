
# Speech

Hello everyone. Today I'm here to share with you some tips on using the Memory Black Box in SpinalHDL. My presentation will focus on the following four aspects: automatically selecting the appropriate implementation based on the size of the Memory, how to enable BIST signals from the top level to all Memories, adding new interfaces to the Memory, and unifying the management of bist logic.

Before we begin, I'd like to take a moment to introduce the tools used in creating this presentation. Slice relied on Typst and various related plugins. Text-to-speech conversion was achieved using StyleTTS2. The speech script itself was written in Chinese and then translated into English with the help of Yi-34b-Chat and Mistral-7b-Inst.

Next, let's get down to business. The Mem interface defined in SpinalHDL is quite elegant and convenient to use. Although the verilog output written by it is very standard, we still need to replace it with standard cell libraries for different processes when using it in practice. In order to maintain the consistency of this interface, to ensure compatibility with lib such as Stream Fifo that have already used Mem, and to reuse the same code across different processes, the memory black box has come into being. By inserting an additional phase of memory replacement before generating verilog, we only need to define wrapper logic for our cell library, and SpinalHDL can automatically complete all Mem replacement work for us. However, the examples given in the SpinalHDL code may be too simple to meet our needs in practical use, so this presentation will share some tips to achieve common requirements.

The following demonstrations are based on modifications of the PhaseMemBlackBoxingDefault implementation in the SpinalHDL library, so let's start by briefly analyzing this official implementation. First, we need to declare the corresponding BlackBox based on the memory you will be using. When defining a Mem and reading/writing to it, corresponding Statements are added under the Component. During the phase before verilog generation, all statements under the component are traversed, and those related to the mem are selected and replaced with custom black boxes, while the original statements are removed. Here we use the rework function of the Component to add new logic to the Component after it has been defined. By following these steps, we can encapsulate our logic code, allowing us to define and use memories in the same way as before, with the added benefit of being able to configure parameters for generating Verilog.

The solution is elegant, but perhaps it is not yet sufficient for more complex functions. I will now introduce several techniques to achieve this. First, the implementation method can be selected based on the size of the memory: For too small memories, the black box is not called; instead, the native writing approach is used, which involves building with registers. We can obtain the bit width and depth by calling getWidth and wordCount on the memory, and when the size is below expectation, use if statements to skip the entire replacement operation. For memories that are too large, they typically need to be divided into multiple memory black boxes. In Spinal, we can define an additional layer of memory wrapper to package multiple memory black boxes and handle related logic; during the replacement operation, the original memory black box is changed to our custom wrapper to achieve automatic splitting.

Next, I will demonstrate how to send signals into the top layer for processing. For signals like bist enable, usually only a connection to the top-level port is required. To meet this demand, we first need to modify the definition of mem black box to include the missing bist enable signal. By calling the parents function of Component, we can obtain information about the parent modules going up in levels, with the first one being the top layer module. If the function returns null, it means that the current module is the top-level module. When using this method to get the top layer module, the Scala compiler does not know which signals you have defined at the top level; therefore, we need to use asInstanceOf to manually tell the Scala compiler that we have defined the bist signal. After that, we can use the pull function to automatically propagate the signal through any number of levels until it reaches the desired module, thus completing the wiring.

Another common requirement is to add extra signals to the mem and be able to operate on these signals in Spinal code. The ideal way would of course be to modify the source code of SpinalHDL, but even without changing the source code, we can still extend this function ourselves and make it look good. Let's assume that there is such a signal on our memory that needs to be brought out for use. First, we need to define a custom SpinalTag, and subsequent wiring will rely on this tag. To avoid messy wiring when defining multiple mem within the same module, this tag needs to carry the mem object itself to determine the correspondence between signals and mems. By using implicit conversion, we can define a function for this additional signal, so that it can be used just like write and readSync. The logic inside this function is quite simple: to tag the signal with our custom tag. Within the phase, we need to traverse all statements under the current module to get all signals. By looking at all tags of each signal, we can find the corresponding signal to complete the wiring. It is worth noting that when traversing the tags, considering that a single signal may be connected to multiple mems, we cannot simply use getTag to obtain our custom tag; instead, we should use getTags to retrieve all tags to avoid missing any connections.

Finally, let's look at how to construct a module at the top level to control all the additional signals for the memories. The expected goal is to leave the logic of driving these extra signals to the user when constructing a module that inherits from BistCtrl. Only requiring the instantiation of this module at the top level, with all wiring automatically completed in the Phase stage. Since we cannot know how many memories need to be controlled when defining the control module, users need to write functions that input are ports and return are units, and our library needs to add an additional phase stage after the traditional MemBlackBox Phase stage to call these functions and build the complete control module. In the regular MemBlackBox Phase stage, we also need to describe the logic of connecting the memories to the control module through defining functions.

At the end, I'd like to briefly demonstrate how a custom lint can be implemented. The implementation is similar to what we have discussed earlier, which involves adding an additional Phase stage before generating Verilog. In this stage, we traverse all Statements and report any usages that do not conform to our requirements. The example I will show you is a lint for resize operations that allows only resizing up, not down.

SpinalHDL's implementation of resize uses specific tags. When checking bitwidths, if such a tag is encountered, the check is skipped. For our custom check, we need to ensure that when this tag is found, we check whether the assignment statement is increasing or decreasing the bitwidth. If it's decreasing, we can use SpinalHDL's internal PendingError function to break the generation and provide error messages in a format consistent with those produced natively by SpinalHDL.

It's important to note that due to the special nature of the tuple-based concatenation feature added later to SpinalHDL, our lint might not be able to detect bitwidth issues in such cases.

My speech concludes here. Due to my limited English proficiency, I am unable to answer questions in real-time. If you have any inquiries, please raise them as issues on GitHub. Thank you!
