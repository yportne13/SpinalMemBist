
# 演讲稿

大家好呀，这次演讲分享的内容是在 SpinalHDL 中使用 Memory Black Box 的一些技巧。主要包括以下四个内容：自动根据 Memory 大小选择合适的实现方式，如何从顶层向所有 Memory 下发 bist 使能信号，如何为 Memory 添加新的接口，以及如何统一管理 bist 逻辑。

在开始之前，请允许我先介绍一下制作本次演讲用到的工具。slice 用到了 typst 和一些相关插件。文本转语音使用的是 StyleTTS2。演讲稿是使用中文写的，然后使用 yi-34b-chat 和 mistral-7b-inst 将其翻译为英语。

接下来让我们步入正题。SpinalHDL 中定义的 Mem 接口十分优雅，使用起来很方便。尽管其输出的 verilog 写法十分标准，我们在实际使用的时候依然需要将其替换为不同工艺的标准单元库。为了维持这个接口的统一，为了兼容诸如 Stream Fifo 这些已经使用了 Mem 的 lib，为了同一份代码能够在不同工艺间复用，memory black box 应运而生。通过在生成 verilog 前插入额外的 memory 替换的 phase 阶段，我们只需要为我们的单元库定义 wrapper 逻辑，SpinalHDL 即可自动为我们完成所有 Mem 的替换工作。但是，SpinalHDL 代码中给的例子比较简单，不一定能满足我们实际使用中的需求，因此本次演讲会分享一些小技巧来实现常用的需求。

接下来的几个演示都是在 SpinalHDL 库中的 PhaseMemBlackBoxingDefault 的基础上修改得到的，因此先让我们简单分析一下这个官方实现。首先，我们需要根据所要使用的存储器声明出对应的 BlackBox。当你在定义一个 Mem 和读写 Mem 时，Component 下会添加对应的 Statement。在生成 verilog 前的 phase 阶段，遍历所有 component 下的 statement，挑出 mem 相关的 statement，替换成自定义的 black box，并移除原始的 statement 即可。这里我们使用 Component 的 rework 函数，来实现在定义完 Component 后为这个 Component 添加新的逻辑。经过以上步骤的封装后，我们在编写逻辑代码时就可以像之前那样定义和使用存储器，只需要配置好生成 verilog 时使用的参数即可。

这个解决方案很优雅，但也许还不太够用。接下来我会介绍几个技巧实现更复杂的功能。首先是根据 mem 尺寸选择不同的实现方式：对于太小的 mem，不调用 black box，依然使用原生写法，也就是用寄存器来搭。。我们可以通过对 mem 调用 getWidth 和 wordCount 获取位宽和深度，当尺寸小于预期时，使用 if 语句跳过整个替换操作即可。对于太大的 mem，通常需要拆分为多个 mem black box。我们可以在 Spinal 中再定义一层 mem wrapper 用来打包多个 mem black box 并处理相关逻辑，在进行替换操作时将原先的 mem black box 改为我们自定义的 wrapper 即可实现自动拆分。

接下来演示一下将信号送入顶层的处理方式。对于诸如 bist 使能这样的信号，通常只需要汇入顶层端口即可。对于这样的需求，首先我们需要修改一下 mem black box 的定义，将缺少的 bist 使能信号补上。对 Component 调用 parents 函数可以获得逐级向上的父模块，其中第一个就是顶层模块。如果调用该函数为空，则表示当前这个模块就是顶层模块。采用这种方式获取顶层模块时，scala 编译器并不知道你在顶层定义了哪些信号，因此我们需要使用 asInstanceOf 来手动告诉 scala 编译器我们定义了 bist_en 这个信号。然后使用 pull 函数来让信号自动穿过任意层级达到你想要的模块，完成连线。

另一个常见需求是为 mem 添加额外信号，并能够在 Spinal 代码中正常的操作这个信号。理想的方式当然是修改 SpinalHDL 的源代码，但是在不改源代码的情况下我们依然可以自行扩展这个功能，并且能够做的很漂亮。假设我们的存储器上有这样一个信号需要引出来使用。首先我们需要自定义一个 SpinalTag，之后的连线就靠这个 tag 来完成。为了避免同一个模块下定义多个 mem 时连线混乱，这个 tag 需要带上 mem 对象本身，来确定信号和 mem 之间的对应关系。利用隐式转换，我们可以为这个额外信号定义一个函数，这样用起来就和 write、readSync 一样了。这个函数内的逻辑很简单，就是为这个信号打上 tag。在 phase 内，我们需要遍历当前模块下的所有 statement 来获取所有信号。通过查看每一个信号的所有 tag，找出对应的信号完成连线即可。需要注意的是，遍历 tag 时，考虑到同一个信号有可能会连到多个 mem，不能简单的使用 getTag 获取我们自定义的 tag，要用 getTags 拿到所有 tag，以免漏连。

最后，让我们看看如何在顶层构造一个模块用来控制所有存储器的额外信号。预期目标是将这些额外信号的驱动逻辑留给使用者在构造继承了 BistCtrl 的模块时自行实现。只需要在顶层例化这个模块，所有连线在 Phase 阶段自动完成。由于在定义控制模块时无法知道共有多少存储器需要控制，因此使用者需要编写的是端口到 unit 的函数，而我们的库需要在传统的 MemBlackBox Phase 阶段之后再额外添加一个 Phase 阶段用来调用这些函数构建完整的控制模块。在常规的 MemBlackBox Phase 阶段，我们同样需要通过定义函数的方式来描述出存储器和 control 模块连线的逻辑。

在结束之前，顺便再演示一个自定义 lint 的实现方式。实现方式和前面介绍的很类似，都是在生成 verilog 前添加一个额外的 Phase 阶段，在这个阶段遍历所有的 Statement，并报出不符合我们要求的写法。这里演示的是 resize 只允许变大不允许变小的 lint。SpinalHDL 的 resize 实现方式是添加特定 tag，在进行位宽检查时如果遇到这个 tag 则跳过检查。那么我们自定义的检查便是在遇到这个 tag 时，检查赋值语句两端的位宽是变大还是变小。如果变小，则可以调用 SpinalHDL 内部封装的报错函数 PendingError 来打断生成，并提供和 SpinalHDL 原生报错信息格式一致的报错内容。需要注意的是，由于后来 SpinalHDL 添加的基于 Tuple 实现拼接的功能比较特殊，这里演示的 lint 功能还检查不到这种情况下的位宽问题。

我的演讲就到这里啦，由于我的英语不好没法实时回答，如果有问题的话欢迎在 github 项目下发 issue 提问，谢谢！
